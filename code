from tkinter import *
import tkinter
from tkinter import filedialog
import numpy as np
from tkinter.filedialog import askopenfilename
import pandas as pd
from tkinter import simpledialog
import seaborn as sns
from imblearn.over_sampling import SMOTE
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.neural_network import MLPClassifier
import os
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve
from sklearn.metrics import roc_auc_score
from sklearn import metrics

main = tkinter.Tk()
main.title("MLP BASED ROBOT NAVIGATION CLASSIFICATION USING ULTRASONIC SENSOR DATA")
main.geometry("1000x650")

global filename
global x_train, y_train, x_test, y_test
global X, Y, y
global le
global dataset

accuracy = []
precision = []
recall = []
fscore = []

global classifier
global cnn_model
global x_train, x_test, y_train, y_test

# Text widget to show logs/info
text = Text(main, height=15, width=110)
text.place(x=50, y=260)

def uploadDataset():
    global filename
    global dataset
    filename = filedialog.askopenfilename(initialdir="Dataset")
    text.delete('1.0', END)
    text.insert(END, filename + ' Loaded\n')
    dataset = pd.read_csv(filename)
    text.insert(END, str(dataset.head()) + "\n\n")

def preprocessDataset():
    global X, y
    global le
    global dataset
    global x_train, y_train, x_test, y_test

    text.delete('1.0', END)
    dataset.fillna(0, inplace=True)
    text.insert(END, str(dataset.head()) + "\n\n")

    le = LabelEncoder()
    dataset['Label'] = le.fit_transform(dataset['Label'])

    X = dataset.iloc[:, :-1]
    y = dataset.iloc[:, -1]

    # Create a count plot
    sns.set(style="darkgrid")  # Set the style of the plot
    plt.figure(figsize=(8, 6))  # Set the figure size

    # Replace 'dataset' with your actual DataFrame and 'Label' with the column name
    ax = sns.countplot(x='Label', data=dataset, palette="Set3")

    plt.title("Count Plot")  # Add a title to the plot
    plt.xlabel("Categories")  # Add label to x-axis
    plt.ylabel("Count")  # Add label to y-axis

    # Annotate each bar with its count value
    for p in ax.patches:
        ax.annotate(f'{p.get_height()}', (p.get_x() + p.get_width() / 2., p.get_height()),
                    ha='center', va='center', fontsize=10, color='black', xytext=(0, 5),
                    textcoords='offset points')

    plt.show()

def analysis():
    # Create a count plot
    global y, X, x_train, x_test, y_train, y_test

    smote = SMOTE(sampling_strategy='auto', random_state=42)
    X, y = smote.fit_resample(X, y)

    text.insert(END, "Total records found in dataset: " + str(X.shape[0]) + "\n\n")

    x_train, x_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)

    text.insert(END, "Total records found in dataset to train: " + str(x_train.shape[0]) + "\n\n")
    text.insert(END, "Total records found in dataset to test: " + str(x_test.shape[0]) + "\n\n")

    print(x_train)

    sns.set(style="darkgrid")  # Set the style of the plot
    plt.figure(figsize=(8, 6))  # Set the figure size

    # Countplot of the labels after resampling
    ax = sns.countplot(x=y, palette="Set3")

    plt.title("Count Plot")  # Add a title to the plot
    plt.xlabel("Categories")  # Add label to x-axis
    plt.ylabel("Count")  # Add label to y-axis

    # Annotate each bar with its count value
    for p in ax.patches:
        ax.annotate(f'{p.get_height()}', (p.get_x() + p.get_width() / 2., p.get_height()),
                    ha='center', va='center', fontsize=10, color='black', xytext=(0, 5),
                    textcoords='offset points')

    plt.show()

def custom_knn_classifier():
    global x_train, x_test, y_train, y_test
    text.delete('1.0', END)

    KNN = KNeighborsClassifier(n_neighbors=10, leaf_size=30, metric='minkowski')
    # Create an instance of KNeighborsClassifier

    # Train
    KNN.fit(x_train, y_train)

    predict = KNN.predict(x_test)

    p = precision_score(y_test, predict, average='macro') * 100
    r = recall_score(y_test, predict, average='macro') * 100
    f = f1_score(y_test, predict, average='macro') * 100
    a = accuracy_score(y_test, predict) * 100

    accuracy.append(a)
    precision.append(p)
    recall.append(r)
    fscore.append(f)

    text.insert(END, "KNN Precision : " + str(p) + "\n")
    text.insert(END, "KNN Recall  : " + str(r) + "\n")
    text.insert(END, "KNN FMeasure : " + str(f) + "\n")
    text.insert(END, "KNN Accuracy : " + str(a) + "\n\n")

    # Compute classification report
    classes = ['Slight-Right-Turn', 'Sharp-Right-Turn', 'Move Forward', 'Slight-Left-Turn']
    report = classification_report(y_test, predict, target_names=classes)

    # Display classification report in the Text widget
    text.insert(END, "Classification Report:\n")
    text.insert(END, report)

    cm = confusion_matrix(y_test, predict)
    plt.figure(figsize=(8, 6))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)
    plt.title('KNeighborsClassifier Confusion Matrix')
    plt.xlabel('Predicted')
    plt.ylabel('Actual')
    plt.show()

def MLPclassifier():
    global x_train, y_train, x_test, y_test
    global MLP
    text.delete('1.0', END)

    # After training with Cross validation, this was derived as the best model.
    MLP = MLPClassifier(activation='logistic', max_iter=1000)  # activation='logistic', alpha=0.01, hidden_layer_sizes=(40,), solver='lbfgs', random_state=1, max_iter=1000

    # commence training -
    MLP.fit(x_train, y_train)

    predict = MLP.predict(x_test)

    p = precision_score(y_test, predict, average='macro', zero_division=0) * 100
    r = recall_score(y_test, predict, average='macro', zero_division=0) * 100
    f = f1_score(y_test, predict, average='macro', zero_division=0) * 100
    a = accuracy_score(y_test, predict) * 100

    accuracy.append(a)
    precision.append(p)
    recall.append(r)
    fscore.append(f)

    # Display precision, recall, F1-score, and accuracy in the Text widget
    text.insert(END, "MLP Precision: " + str(p) + "\n")
    text.insert(END, "MLP Recall: " + str(r) + "\n")
    text.insert(END, "MLP FMeasure: " + str(f) + "\n")
    text.insert(END, "MLP Accuracy: " + str(a) + "\n\n")

    classes = ['Slight-Right-Turn', 'Sharp-Right-Turn', 'Move Forward', 'Slight-Left-Turn']

    # Compute confusion matrix
    cm = confusion_matrix(y_test, predict)

    # Compute classification report
    report = classification_report(y_test, predict, target_names=classes)

    # Display classification report in the Text widget
    text.insert(END, "Classification Report:\n")
    text.insert(END, report)

    plt.figure(figsize=(8, 6))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)
    plt.title('MLPclassifier Confusion Matrix')
    plt.xlabel('Predicted')
    plt.ylabel('Actual')
    plt.show()

def Prediction():
    filename = filedialog.askopenfilename(initialdir="Dataset")
    text.delete('1.0', END)
    text.insert(END, f'{filename} Loaded\n')

    test = pd.read_csv(filename)
    text.delete('1.0', END)

    for i in range(len(test)):
        input_data = test.iloc[i, :].values.reshape(1, -1)
        predict = MLP.predict(input_data)  # Assuming MLP.predict expects a 2D array
        text.insert(END, f'Input data for row {i}: {input_data}\n')

        # predict may be array-like; ensure we extract scalar
        try:
            pred_val = int(np.array(predict).ravel()[0])
        except:
            pred_val = int(predict)

        if pred_val == 1:
            predicted_data = "Slight-Right-Turn"
        elif pred_val == 2:
            predicted_data = "Sharp-Right-Turn"
        elif pred_val == 3:
            predicted_data = "Move Forward"
        elif pred_val == 4:
            predicted_data = "Slight-Left-Turn"
        else:
            predicted_data = f"Class-{pred_val}"

        text.insert(END, f'Predicted output for row {i}: {predicted_data}\n')

def graph():
    # Create a DataFrame
    df = pd.DataFrame([
        ['KNN', 'Precision', precision[0]],
        ['KNN', 'Recall', recall[0]],
        ['KNN', 'F1 Score', fscore[0]],
        ['KNN', 'Accuracy', accuracy[0]],
        ['MLP', 'Precision', precision[-1]],
        ['MLP', 'Recall', recall[-1]],
        ['MLP', 'F1 Score', fscore[-1]],
        ['MLP', 'Accuracy', accuracy[-1]],
    ], columns=['Parameters', 'Algorithms', 'Value'])

    # Pivot the DataFrame and plot the graph
    pivot_df = df.pivot_table(index='Parameters', columns='Algorithms', values='Value', aggfunc='first')
    pivot_df.plot(kind='bar')

    # Set graph properties
    plt.title('Classifier Performance Comparison')
    plt.ylabel('Score')
    plt.xticks(rotation=0)
    plt.tight_layout()

    # Display the graph
    plt.show()

def close():
    main.destroy()

# GUI elements
font = ('times', 16, 'bold')
title = Label(main, text='MLP BASED ROBOT NAVIGATION CLASSIFICATION\nUSING ULTRASONIC SENSOR DATA', justify=LEFT)
title.config(bg='lavender blush', fg='black')
title.config(font=font)
title.config(height=3, width=120)
title.place(x=100, y=5)
title.pack()

font1 = ('times', 13, 'bold')


uploadButton = Button(main, text="Upload Dataset", command=uploadDataset)
uploadButton.place(x=200, y=100)
uploadButton.config(font=font1)

preprocessButton = Button(main, text="Preprocess Dataset", command=preprocessDataset)
preprocessButton.place(x=500, y=100)
preprocessButton.config(font=font1)

analysisButton = Button(main, text="Applying SMOTE", command=analysis)
analysisButton.place(x=200, y=150)
analysisButton.config(font=font1)

knnButton = Button(main, text="KNeighborsClassifier", command=custom_knn_classifier)
knnButton.place(x=500, y=150)
knnButton.config(font=font1)

LRButton = Button(main, text="MLPclassifierclassifier", command=MLPclassifier)
LRButton.place(x=200, y=200)
LRButton.config(font=font1)

predictButton = Button(main, text="Prediction", command=Prediction)
predictButton.place(x=500, y=200)
predictButton.config(font=font1)

graphButton = Button(main, text="Comparison Graph", command=graph)
graphButton.place(x=200, y=250)
graphButton.config(font=font1)

exitButton = Button(main, text="Exit", command=close)
exitButton.place(x=500, y=250)
exitButton.config(font=font1)

font1 = ('times', 12, 'bold')

text = Text(main, height=20, width=120)
scroll = Scrollbar(text)

text.configure(yscrollcommand=scroll.set)
text.place(x=10, y=300)

text.config(font=font1)

main.config(bg='LightSteelBlue1')

main.mainloop()